"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[311],{1293:function(e,t,n){n.d(t,{Z:function(){return l}});var i=n(7294),a=n(860),s=(n(8846),"tag_sbMh"),r={ipm:{long:"Input Parameter Model",definition:"Contains all relevant test parameters and their values. The IPM is used to generate the test inputs (one value is assigned to each parameter) by using t-way combinatorial testing. Seperate IPMs are defined for each test template, depending on the requirement that the test template checks. Dynamically inserted constraints are applied to the IPM to ensure that for each parameter only values are used that are supported by the SUT."},sut:{long:"System Under Test",definition:"The TLS client or server that you want to test using TLS-Anvil."},"test input(s)?":{long:"Test Input",definition:"A test input is basically a dictionary that contains a single value for each parameter of an IPM. Test inputs are automatically generated from the IPM using t-way combinatorial testing. A test template is executed multiple times using a different test input for each execution."},"test template(s)?":{long:"Test Template",definition:"A test template defines the desired outcome for all test cases derived from it. Thus, it represents a test oracle that is applicable to all derived test cases. Each test template tests a different requirement and is implemented as a normal JUnit test. It basically consists of two building blocks. First it defines which TLS messages are sent and expected to be received by the test suite. Second, it defines when a test case succeeds or fails."},"test case(s)?":{long:"Test Case",definition:"A test case is the (automatically) instantiated version of test template with one specific test input."}},o=Object.keys(r);function l(e){var t=e.id,n=o.map((function(e){return[new RegExp(e,"i").test(t),e]})).filter((function(e){return e[0]}))[0][1],l=r[n];return i.createElement(i.Fragment,null,i.createElement(a.ZP,{content:i.createElement(d,{details:l}),placement:"bottom",arrow:!0,hideOnClick:!0},i.createElement("span",{className:s},t,"\xa0\u24d8")))}function d(e){var t=e.details;return i.createElement(i.Fragment,null,i.createElement("div",null,t.long),i.createElement("hr",{style:{marginTop:"4px",marginBottom:"4px"}}),i.createElement("div",null,t.definition))}},4238:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return d},default:function(){return h},frontMatter:function(){return l},metadata:function(){return c},toc:function(){return m}});var i=n(7462),a=n(3366),s=(n(7294),n(3905)),r=n(1293),o=["components"],l={},d="Test Template Example",c={unversionedId:"Adding-New-Tests/Test-Case-Example",id:"Adding-New-Tests/Test-Case-Example",title:"Test Template Example",description:"In the following we want to discuss a test template example.",source:"@site/docs/05-Adding-New-Tests/02-Test-Case-Example.md",sourceDirName:"05-Adding-New-Tests",slug:"/Adding-New-Tests/Test-Case-Example",permalink:"/docs/Adding-New-Tests/Test-Case-Example",draft:!1,editUrl:"https://github.com/tls-attacker/TLS-Anvil/tree/main/Docs/docs/05-Adding-New-Tests/02-Test-Case-Example.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Development Environment Setup",permalink:"/docs/Adding-New-Tests/Setup-Dev-Environment"},next:{title:"Base IPMs",permalink:"/docs/Adding-New-Tests/IPM-Models"}},p={},m=[{value:"Annotations",id:"annotations",level:3},{value:"Test function",id:"test-function",level:3}],u={toc:m};function h(e){var t=e.components,n=(0,a.Z)(e,o);return(0,s.kt)("wrapper",(0,i.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"test-template-example"},"Test Template Example"),(0,s.kt)("p",null,"In the following we want to discuss a test template example.\nThis template aims to test if the ",(0,s.kt)(r.Z,{id:"SUT",mdxType:"Definition"})," sends the correct TLS alert, if the CBC padding is incorrect. This test works for client and servers by changing the first application message to use an invalid padding. The template is only executed when the SUT supports a CBC Cipher Suite, otherwise it is skipped. The padding error is injected into multiple positions. The positions are determined by combinatorial testing."),(0,s.kt)("h3",{id:"annotations"},"Annotations"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Line 1: Generic ",(0,s.kt)("inlineCode",{parentName:"li"},"TlsTest")," annotation that activates the TLS-Anvil test execution lifecycle. In addition basic parameters are added automatically to the ",(0,s.kt)(r.Z,{id:"IPM",mdxType:"Definition"}),"."),(0,s.kt)("li",{parentName:"ul"},"Line 5-8: Those annotations modify the IPM",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"Line 5: Changes the default IPM model"),(0,s.kt)("li",{parentName:"ul"},"Line 6: Adds additional parameters to the IPM"),(0,s.kt)("li",{parentName:"ul"},"Line 7: Adds a constraint to the Cipher Suite parameter of the IPM, so that the test only runs when a CBC Cipher Suite is selected. The ",(0,s.kt)("inlineCode",{parentName:"li"},"isCBC")," method is called on the TLS-Attacker Cipher Suite enum."),(0,s.kt)("li",{parentName:"ul"},"Line 8: Adds a constraint to the Record Length parameter. The ",(0,s.kt)("inlineCode",{parentName:"li"},"recordLengthAllowsModification")," method is called on the current class (line 43), given the selected value as argument."))),(0,s.kt)("li",{parentName:"ul"},"Line 9-13: Each test is annotated with categories and a severity level. Depending on the test result, a score is calculated for each test. Since it is not possible to choose the categories and severity levels objectively, those are not mentioned in our USENIX Security paper.")),(0,s.kt)("h3",{id:"test-function"},"Test function"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Line 15: This is line basically part of every test case, it generates the TLS-Attacker ",(0,s.kt)("inlineCode",{parentName:"li"},"Config")," that defines how the TLS-Attacker Server/Client should behave (e.g. which algorithms are offered, etc.)"),(0,s.kt)("li",{parentName:"ul"},"Line 17-18: An application message is created from which the padding is invalidated. The message that is received from the config is set inside the ",(0,s.kt)("inlineCode",{parentName:"li"},"AppMsgLengthDerivation.applyToConfig")," method."),(0,s.kt)("li",{parentName:"ul"},"Line 20-24: A bitmask is generated that xored on the padding. During the parameter value generation a byte and bit position is chosen by the combinatorial testing algorithm. From those positions the bitmask is generated during the test execution."),(0,s.kt)("li",{parentName:"ul"},"Line 26-33: A TLS-Attacker ",(0,s.kt)("inlineCode",{parentName:"li"},"WorkflowTrace")," is generated that performs a complete handshake and sends an application message after the handshake."),(0,s.kt)("li",{parentName:"ul"},"Line 35-41: The WorkflowTrace is scheduled to be sent. After the handshake is completed, the lambda function get's executed that determines the test result for a single ",(0,s.kt)(r.Z,{id:"test case",mdxType:"Definition"}),". The result of the test template is determined by all test case results.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-java",metastring:"showLineNumbers",showLineNumbers:!0},'@TlsTest(description = "Each uint8 in the padding data " +\n        "vector MUST be filled with the padding length value. The receiver " +\n        "MUST check this padding and MUST use the bad_record_mac alert to " +\n        "indicate padding errors.")\n@ModelFromScope(baseModel = ModelType.CERTIFICATE)\n@ScopeExtensions({DerivationType.APP_MSG_LENGHT, DerivationType.PADDING_BITMASK})\n@ValueConstraints(affectedTypes = {DerivationType.CIPHERSUITE}, methods = "isCBC")\n@DynamicValueConstraints(affectedTypes = DerivationType.RECORD_LENGTH, methods = "recordLengthAllowsModification")\n@SecurityCategory(SeverityLevel.HIGH)\n@CryptoCategory(SeverityLevel.CRITICAL)\n@RecordLayerCategory(SeverityLevel.CRITICAL)\n@AlertCategory(SeverityLevel.HIGH)\n@ComplianceCategory(SeverityLevel.HIGH)\npublic void invalidCBCPadding(ArgumentsAccessor argumentAccessor, WorkflowRunner runner) {\n    Config c = getPreparedConfig(argumentAccessor, runner);\n\n    ApplicationMessage appData = new ApplicationMessage();\n    appData.setData(Modifiable.explicit(c.getDefaultApplicationMessageData().getBytes()));\n\n    byte[] modificationBitmask = derivationContainer.buildBitmask();\n\n    Record record = new Record();\n    record.setComputations(new RecordCryptoComputations());\n    record.getComputations().setPadding(Modifiable.xor(modificationBitmask, 0));\n\n    SendAction sendAction = new SendAction(appData);\n    sendAction.setRecords(record);\n\n    WorkflowTrace workflowTrace = runner.generateWorkflowTrace(WorkflowTraceType.HANDSHAKE);\n    workflowTrace.addTlsActions(\n            sendAction,\n            new ReceiveAction(new AlertMessage())\n    );\n\n    runner.execute(workflowTrace, c).validateFinal(i -> {\n        WorkflowTrace trace = i.getWorkflowTrace();\n        Validator.receivedFatalAlert(i);\n\n        AlertMessage msg = trace.getFirstReceivedMessage(AlertMessage.class);\n        Validator.testAlertDescription(i, AlertDescription.BAD_RECORD_MAC, msg);\n    });\n}\n\npublic boolean recordLengthAllowsModification(Integer lengthCandidate) {\n    return lengthCandidate >= 50;\n}\n')))}h.isMDXComponent=!0}}]);