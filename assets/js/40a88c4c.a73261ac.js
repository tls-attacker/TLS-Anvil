"use strict";(self.webpackChunktls_anvil_docs=self.webpackChunktls_anvil_docs||[]).push([[716],{8432:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>c,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"Docker-Library","title":"Using the TLS-Docker-Library","description":"The TLS-Docker-Library is a collection of Dockerfiles and scripts for building and running various TLS implementations.","source":"@site/docs/06-Docker-Library.md","sourceDirName":".","slug":"/Docker-Library","permalink":"/docs/Docker-Library","draft":false,"unlisted":false,"editUrl":"https://github.com/tls-attacker/TLS-Anvil/tree/main/Docs/docs/06-Docker-Library.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Modifying the IPM","permalink":"/docs/Adding-New-Tests/Modifying-the-IPM-Model"},"next":{"title":"TLS-Anvil Jenkins Plugin","permalink":"/docs/Jenkins-Plugin"}}');var t=i(4848),s=i(8453);const c={},o="Using the TLS-Docker-Library",l={},a=[{value:"Testing Built Library Containers Using TLS-Anvil",id:"testing-built-library-containers-using-tls-anvil",level:2},{value:"Server Images",id:"server-images",level:3},{value:"Client Images",id:"client-images",level:3}];function d(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"using-the-tls-docker-library",children:"Using the TLS-Docker-Library"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.a,{href:"https://github.com/tls-attacker/Tls-docker-library",children:"TLS-Docker-Library"})," is a collection of Dockerfiles and scripts for building and running various TLS implementations.",(0,t.jsx)(n.br,{}),"\n","It can be used to test example server and client implementations of multiple TLS libraries."]}),"\n",(0,t.jsx)(n.p,{children:"Refer to the repository's README file to learn how to build the Docker containers yourself."}),"\n",(0,t.jsx)(n.p,{children:"In brief, the steps are:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Run ",(0,t.jsx)(n.code,{children:"./setup.sh"})," to generate the base images and certificates."]}),"\n",(0,t.jsxs)(n.li,{children:["Navigate to ",(0,t.jsx)(n.code,{children:"src/main/resources/images"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Run ",(0,t.jsx)(n.code,{children:"python3 build.py -l image-name:version"})," specifying the implementation name and version you want to build.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["To build the latest version, use the ",(0,t.jsx)(n.code,{children:":latest"})," tag."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"testing-built-library-containers-using-tls-anvil",children:"Testing Built Library Containers Using TLS-Anvil"}),"\n",(0,t.jsx)(n.p,{children:"After building an image of the desired library, you need to create and start the container, then connect it to TLS-Anvil."}),"\n",(0,t.jsx)(n.p,{children:"The process differs for server and client images."}),"\n",(0,t.jsx)(n.p,{children:"To learn how to create and run a container for a specific implementation, go to that implementation\u2019s subfolder, where you will find a README with detailed instructions."}),"\n",(0,t.jsx)(n.h3,{id:"server-images",children:"Server Images"}),"\n",(0,t.jsx)(n.p,{children:"Server images typically launch a binary server example of the library in a loop."}),"\n",(0,t.jsxs)(n.p,{children:["Arguments passed to the Docker container after the image name are forwarded to the server executable. For example, the image ",(0,t.jsx)(n.code,{children:"openssl-server:1.1.1i"})," uses the entrypoint ",(0,t.jsx)(n.code,{children:"openssl s_server"}),". Any arguments you pass after ",(0,t.jsx)(n.code,{children:"docker run openssl-server:1.1.1i ..."})," are passed to the ",(0,t.jsx)(n.code,{children:"openssl"})," executable."]}),"\n",(0,t.jsxs)(n.p,{children:["Many server implementations require certificates, which are generated when you run ",(0,t.jsx)(n.code,{children:"./setup.sh"}),". These certificates are stored in the Docker volume ",(0,t.jsx)(n.code,{children:"cert-data"})," and can be used with any image."]}),"\n",(0,t.jsx)(n.p,{children:"For example, to start an OpenSSL server with an RSA certificate:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"docker run -v cert-data:/certs/ openssl-server:1.1.1i -port 8443 -cert /certs/rsa2048cert.pem -key /certs/rsa2048key.pem\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"-v"})," option binds the ",(0,t.jsx)(n.code,{children:"cert-data"})," volume to the container at ",(0,t.jsx)(n.code,{children:"/certs/"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"The server will listen on port 8443 inside the container. Since the container\u2019s ports are isolated, to connect externally you must:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Add both the server container and TLS-Anvil container to the same Docker network (see our ",(0,t.jsx)(n.a,{href:"/docs/Quick-Start/Server-Testing",children:"example"}),")"]}),"\n",(0,t.jsxs)(n.li,{children:["Or expose the port with ",(0,t.jsx)(n.code,{children:"-p 8443:8443"})]}),"\n",(0,t.jsxs)(n.li,{children:["Or add the container to the host network using ",(0,t.jsx)(n.code,{children:"--network host"})]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["If using a Docker network, the server will be reachable via its container name (which you can set with ",(0,t.jsx)(n.code,{children:"--name ..."}),"). Otherwise, if you expose the port or use the host network, it will be reachable via ",(0,t.jsx)(n.code,{children:"localhost:8443"}),".",(0,t.jsx)(n.br,{}),"\n","This address is what you should use in TLS-Anvil\u2019s ",(0,t.jsx)(n.code,{children:"-connect ..."})," parameter."]}),"\n",(0,t.jsx)(n.h3,{id:"client-images",children:"Client Images"}),"\n",(0,t.jsxs)(n.p,{children:["Client images run a small web server that listens on port 8090. Command-line arguments passed after the image name are forwarded to the client executable. However, unlike server images, the client executable runs only when a GET request is sent to the ",(0,t.jsx)(n.code,{children:"/trigger"})," endpoint of the web server."]}),"\n",(0,t.jsx)(n.p,{children:"For example, to start the OpenSSL client:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"docker run openssl-client:1.1.1i -connect localhost:8443\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"-connect ..."})," argument is passed directly to ",(0,t.jsx)(n.code,{children:"openssl s_client"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"You must ensure TLS-Anvil can access the client\u2019s web server (port 8090), and the client can reach TLS-Anvil to connect. This can be done by:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Adding the client and TLS-Anvil containers to the same Docker network (see our ",(0,t.jsx)(n.a,{href:"/docs/Quick-Start/Client-Testing",children:"example"}),")","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The client can connect to TLS-Anvil using its container name"}),"\n",(0,t.jsx)(n.li,{children:"TLS-Anvil can connect to the client using its container name"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Exposing port 8090 on the client with ",(0,t.jsx)(n.code,{children:"-p 8090:8090"})," and exposing the server listening port on the TLS-Anvil container (if also run in Docker)","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The client can connect to TLS-Anvil using the IP ",(0,t.jsx)(n.code,{children:"172.17.0.1"})," or ",(0,t.jsx)(n.code,{children:"host.docker.internal"})]}),"\n",(0,t.jsxs)(n.li,{children:["TLS-Anvil can reach the client container using ",(0,t.jsx)(n.code,{children:"172.17.0.1"})," or ",(0,t.jsx)(n.code,{children:"host.docker.internal"})," (if in a container), or ",(0,t.jsx)(n.code,{children:"localhost"})," (if run on the host)"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Adding the client (and TLS-Anvil) to the host network using ",(0,t.jsx)(n.code,{children:"--network host"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The client can connect to TLS-Anvil using ",(0,t.jsx)(n.code,{children:"localhost"})]}),"\n",(0,t.jsxs)(n.li,{children:["TLS-Anvil can connect to the client using ",(0,t.jsx)(n.code,{children:"localhost"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["In client testing mode, TLS-Anvil uses a ",(0,t.jsx)(n.em,{children:"trigger script"})," that it calls whenever it wants the client to connect.",(0,t.jsx)(n.br,{}),"\n","When using TLS-Docker-Library images, the trigger script typically uses ",(0,t.jsx)(n.code,{children:"curl"})," to access the client\u2019s ",(0,t.jsx)(n.code,{children:"/trigger"})," endpoint."]}),"\n",(0,t.jsx)(n.p,{children:"For example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"docker run --network host -v $(pwd):/output/ ghcr.io/tls-attacker/tlsanvil:latest client -port 8443 -triggerScript curl localhost:8090/trigger\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["You can also execute a client implementation binary directly in the ",(0,t.jsx)(n.code,{children:"-triggerScript"})," parameter."]})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>c,x:()=>o});var r=i(6540);const t={},s=r.createContext(t);function c(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);