"use strict";(self.webpackChunktls_anvil_docs=self.webpackChunktls_anvil_docs||[]).push([[645],{5229:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/files/TLS-Anvil-Paper-c3dbb77c9b27783fe7998d09765061c4.pdf"},6562:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/Architecture-40dfc74d544fd3fdfa84308722816afd.png"},6823:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>d,contentTitle:()=>c,default:()=>u,frontMatter:()=>l,metadata:()=>n,toc:()=>o});const n=JSON.parse('{"id":"Architecture","title":"Architecture","description":"The diagram below illustrates the general architecture of TLS-Anvil, highlighting the different phases executed during a test run.","source":"@site/docs/04-Architecture.md","sourceDirName":".","slug":"/Architecture","permalink":"/docs/Architecture","draft":false,"unlisted":false,"editUrl":"https://github.com/tls-attacker/TLS-Anvil/tree/main/Docs/docs/04-Architecture.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Compare with Expected Results","permalink":"/docs/Advanced-Features/Expected-Results"},"next":{"title":"Adding New Tests","permalink":"/docs/category/adding-new-tests"}}');var i=s(4848),r=s(8453),a=s(7400);const l={},c="Architecture",d={},o=[{value:"Code-related Information",id:"code-related-information",level:3},{value:"Key Concepts",id:"key-concepts",level:3},{value:"TLS-Anvil Modules",id:"tls-anvil-modules",level:3}];function h(e){const t={a:"a",br:"br",code:"code",h1:"h1",h3:"h3",header:"header",hr:"hr",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"architecture",children:"Architecture"})}),"\n",(0,i.jsxs)(t.p,{children:["The diagram below illustrates the general architecture of TLS-Anvil, highlighting the different phases executed during a test run.",(0,i.jsx)(t.br,{}),"\n","These phases are explained in detail in our ",(0,i.jsx)(t.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:s(5229).A+"",children:"USENIX Security Paper, Section 4.1"}),"."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"TLS-Anvil Architecture",src:s(6562).A+"",width:"1402",height:"565"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h3,{id:"code-related-information",children:"Code-related Information"}),"\n",(0,i.jsxs)(t.p,{children:["TLS-Anvil is implemented in ",(0,i.jsx)(t.strong,{children:"Java"})," and leverages several key libraries:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"https://junit.org/",children:"JUnit 5"})," \u2013 Testing engine. TLS-Anvil extensively uses JUnit's extension system."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"https://github.com/tls-attacker/TLS-Attacker",children:"TLS-Attacker"})," \u2013 Core TLS stack."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"https://github.com/tls-attacker/TLS-Scanner",children:"TLS-Scanner"})," \u2013 Scanner based on TLS-Attacker, used for feature extraction."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"https://coffee4j.github.io/",children:"coffee4j"})," \u2013 Library for combinatorial testing."]}),"\n"]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h3,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,i.jsxs)(t.p,{children:["Every ",(0,i.jsx)(a.A,{id:"test template"})," represents a JUnit test function augmented with Java annotations that define an ",(0,i.jsx)(a.A,{id:"IPM"}),".",(0,i.jsx)(t.br,{}),"\n","Most importantly, these annotations enable the TLS-Anvil test lifecycle, which manages TLS message exchanges with the System Under Test (SUT)."]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h3,{id:"tls-anvil-modules",children:"TLS-Anvil Modules"}),"\n",(0,i.jsx)(t.p,{children:"TLS-Anvil is organized into two Java modules:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"TLS-Testsuite:"}),(0,i.jsx)(t.br,{}),"\n","The main module containing all test templates.",(0,i.jsx)(t.br,{}),"\n","These templates reside in the ",(0,i.jsx)(t.code,{children:"de.rub.nds.tlstest.suite.tests"})," package, further subdivided into:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"server"})," tests"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"client"})," tests"]}),"\n",(0,i.jsxs)(t.li,{children:["Tests applicable to ",(0,i.jsx)(t.code,{children:"both"})," peers",(0,i.jsx)(t.br,{}),"\n","Inside these, tests are organized by relevant RFCs."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"TLS-Test-Framework:"}),(0,i.jsx)(t.br,{}),"\n","This module contains all JUnit extensions and the core test execution logic."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.p,{children:"See the next chapter for an example test template and instructions on adding new templates."})]})}function u(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},7400:(e,t,s)=>{s.d(t,{A:()=>c});s(6540);var n=s(6822);s(8091);const i={tag:"tag_sbMh"},r={ipm:{long:"Input Parameter Model",definition:"Contains all relevant test parameters and their values. The IPM is used to generate the test inputs (one value is assigned to each parameter) by using t-way combinatorial testing. Seperate IPMs are defined for each test template, depending on the requirement that the test template checks. Dynamically inserted constraints are applied to the IPM to ensure that for each parameter only values are used that are supported by the SUT."},sut:{long:"System Under Test",definition:"The TLS client or server that you want to test using TLS-Anvil."},"test input(s)?":{long:"Test Input",definition:"A test input is basically a dictionary that contains a single value for each parameter of an IPM. Test inputs are automatically generated from the IPM using t-way combinatorial testing. A test template is executed multiple times using a different test input for each execution."},"test template(s)?":{long:"Test Template",definition:"A test template defines the desired outcome for all test cases derived from it. Thus, it represents a test oracle that is applicable to all derived test cases. Each test template tests a different requirement and is implemented as a normal JUnit test. It basically consists of two building blocks. First it defines which TLS messages are sent and expected to be received by the test suite. Second, it defines when a test case succeeds or fails."},"test case(s)?":{long:"Test Case",definition:"A test case is the (automatically) instantiated version of test template with one specific test input."}};var a=s(4848);const l=Object.keys(r);function c({id:e}){const t=l.map((t=>[new RegExp(t,"i").test(e),t])).filter((e=>e[0]))[0][1],s=r[t];return(0,a.jsx)(a.Fragment,{children:(0,a.jsx)(n.Ay,{content:(0,a.jsx)(d,{details:s}),placement:"bottom",arrow:!0,hideOnClick:!0,children:(0,a.jsxs)("span",{className:i.tag,children:[e,"\xa0\u24d8"]})})})}function d({details:e}){return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)("div",{children:e.long}),(0,a.jsx)("hr",{style:{marginTop:"4px",marginBottom:"4px"}}),(0,a.jsx)("div",{children:e.definition})]})}}}]);