"use strict";(self.webpackChunktls_anvil_docs=self.webpackChunktls_anvil_docs||[]).push([[613],{7400:(e,t,i)=>{i.d(t,{A:()=>o});i(6540);var a=i(6822);i(8091);const s={tag:"tag_sbMh"},n={ipm:{long:"Input Parameter Model",definition:"Contains all relevant test parameters and their values. The IPM is used to generate the test inputs (one value is assigned to each parameter) by using t-way combinatorial testing. Seperate IPMs are defined for each test template, depending on the requirement that the test template checks. Dynamically inserted constraints are applied to the IPM to ensure that for each parameter only values are used that are supported by the SUT."},sut:{long:"System Under Test",definition:"The TLS client or server that you want to test using TLS-Anvil."},"test input(s)?":{long:"Test Input",definition:"A test input is basically a dictionary that contains a single value for each parameter of an IPM. Test inputs are automatically generated from the IPM using t-way combinatorial testing. A test template is executed multiple times using a different test input for each execution."},"test template(s)?":{long:"Test Template",definition:"A test template defines the desired outcome for all test cases derived from it. Thus, it represents a test oracle that is applicable to all derived test cases. Each test template tests a different requirement and is implemented as a normal JUnit test. It basically consists of two building blocks. First it defines which TLS messages are sent and expected to be received by the test suite. Second, it defines when a test case succeeds or fails."},"test case(s)?":{long:"Test Case",definition:"A test case is the (automatically) instantiated version of test template with one specific test input."}};var r=i(4848);const d=Object.keys(n);function o({id:e}){const t=d.map((t=>[new RegExp(t,"i").test(e),t])).filter((e=>e[0]))[0][1],i=n[t];return(0,r.jsx)(r.Fragment,{children:(0,r.jsx)(a.Ay,{content:(0,r.jsx)(l,{details:i}),placement:"bottom",arrow:!0,hideOnClick:!0,children:(0,r.jsxs)("span",{className:s.tag,children:[e,"\xa0\u24d8"]})})})}function l({details:e}){return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)("div",{children:e.long}),(0,r.jsx)("hr",{style:{marginTop:"4px",marginBottom:"4px"}}),(0,r.jsx)("div",{children:e.definition})]})}},8023:(e,t,i)=>{i.d(t,{A:()=>s});i(6540);var a=i(4848);function s({path:e}){const t=e.replace(".java","").split("/").reverse();return(0,a.jsx)(a.Fragment,{children:(0,a.jsx)("a",{href:"https://github.com/tls-attacker/TLS-Anvil/tree/main/"+e,children:t[0]})})}},8114:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>m,frontMatter:()=>o,metadata:()=>a,toc:()=>h});const a=JSON.parse('{"id":"Adding-New-Tests/Modifying-the-IPM-Model","title":"Modifying the IPM","description":"As described earlier, TLS-Anvil defines four common IPMs. Occasionally, different parameters and/or parameter values need to be included in the IPM. To support this, the Anvil-Core-Framework provides several test template annotations that allow modification of a selected base IPM. These annotations are explained below.","source":"@site/docs/05-Adding-New-Tests/04-Modifying-the-IPM-Model.md","sourceDirName":"05-Adding-New-Tests","slug":"/Adding-New-Tests/Modifying-the-IPM-Model","permalink":"/docs/Adding-New-Tests/Modifying-the-IPM-Model","draft":false,"unlisted":false,"editUrl":"https://github.com/tls-attacker/TLS-Anvil/tree/main/Docs/docs/05-Adding-New-Tests/04-Modifying-the-IPM-Model.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Base IPMs","permalink":"/docs/Adding-New-Tests/IPM-Models"},"next":{"title":"Using the TLS-Docker-Library","permalink":"/docs/Docker-Library"}}');var s=i(4848),n=i(8453),r=i(8023),d=i(7400);const o={},l="Modifying the IPM",c={},h=[{value:"Modifying Parameters",id:"modifying-parameters",level:2},{value:"<code>IncludeParameter</code>",id:"includeparameter",level:3},{value:"<code>ExcludeParameter</code>",id:"excludeparameter",level:3},{value:"Modifying Parameter Values",id:"modifying-parameter-values",level:2},{value:"<code>DynamicValueConstraints</code>",id:"dynamicvalueconstraints",level:3},{value:"<code>ValueConstraint</code>",id:"valueconstraint",level:3},{value:"<code>ExplicitValues</code>",id:"explicitvalues",level:3},{value:"<code>ExplicitModelingConstraints</code>",id:"explicitmodelingconstraints",level:3}];function p(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,n.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"modifying-the-ipm",children:"Modifying the IPM"})}),"\n",(0,s.jsx)(t.p,{children:"As described earlier, TLS-Anvil defines four common IPMs. Occasionally, different parameters and/or parameter values need to be included in the IPM. To support this, the Anvil-Core-Framework provides several test template annotations that allow modification of a selected base IPM. These annotations are explained below."}),"\n",(0,s.jsx)(t.h2,{id:"modifying-parameters",children:"Modifying Parameters"}),"\n",(0,s.jsx)(t.h3,{id:"includeparameter",children:(0,s.jsx)(t.code,{children:"IncludeParameter"})}),"\n",(0,s.jsxs)(t.p,{children:["Accepts a string corresponding to the enum value of ",(0,s.jsx)(t.code,{children:"TlsParameterType"})," for the parameter to be added to the base IPM. The values for the parameter are automatically derived from the features supported by the ",(0,s.jsx)(d.A,{id:"SUT"})," as well as general constraints."]}),"\n",(0,s.jsx)(t.h3,{id:"excludeparameter",children:(0,s.jsx)(t.code,{children:"ExcludeParameter"})}),"\n",(0,s.jsxs)(t.p,{children:["Accepts a string corresponding to the enum value of ",(0,s.jsx)(t.code,{children:"TlsParameterType"})," for the parameter to be removed from the base IPM."]}),"\n",(0,s.jsx)(t.h2,{id:"modifying-parameter-values",children:"Modifying Parameter Values"}),"\n",(0,s.jsx)(t.h3,{id:"dynamicvalueconstraints",children:(0,s.jsx)(t.code,{children:"DynamicValueConstraints"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:"public @interface DynamicValueConstraints {\n    Class<?> clazz() default Object.class;\n    String[] affectedIdentifiers();\n    String[] methods();\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Each method listed in the ",(0,s.jsx)(t.code,{children:"methods"})," array is invoked with the chosen parameter value of the parameter defined at the corresponding index of the ",(0,s.jsx)(t.code,{children:"affectedIdentifiers"})," array. If no ",(0,s.jsx)(t.code,{children:"clazz"})," is specified, the method is called via reflection on the same class as the test template."]}),"\n",(0,s.jsxs)(t.p,{children:["The method should return a ",(0,s.jsx)(t.code,{children:"boolean"})," value. If the return value is ",(0,s.jsx)(t.code,{children:"true"}),", the combination of parameter values is considered valid test input; otherwise, the test input is skipped."]}),"\n",(0,s.jsx)(t.h3,{id:"valueconstraint",children:(0,s.jsx)(t.code,{children:"ValueConstraint"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:"public @interface ValueConstraints {\n    DerivationType identifier();\n    String method();\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Some parameter values are based on TLS-Attacker enums, e.g., ",(0,s.jsx)(r.A,{path:"TLS-Test-Framework/src/main/java/de/rub/nds/tlstest/framework/model/derivationParameter/CipherSuiteDerivation.java"}),". These enums already include methods that return a ",(0,s.jsx)(t.code,{children:"boolean"})," indicating whether the enum value fulfills certain criteria."]}),"\n",(0,s.jsxs)(t.p,{children:["The method specified in the ",(0,s.jsx)(t.code,{children:"method"})," field is called via reflection on the selected enum corresponding to the ",(0,s.jsx)(t.code,{children:"identifier"}),". If the method returns ",(0,s.jsx)(t.code,{children:"true"}),", the parameter combination is considered valid test input; otherwise, the test input is skipped."]}),"\n",(0,s.jsx)(t.h3,{id:"explicitvalues",children:(0,s.jsx)(t.code,{children:"ExplicitValues"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:"public @interface ExplicitValues {\n    Class<?> clazz() default Object.class;\n    String[] affectedIdentifiers();\n    String[] methods();\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["In some cases, explicit values should be considered as parameter values regardless of the features supported by the ",(0,s.jsx)(d.A,{id:"SUT"}),". This annotation assigns such explicit values to parameters."]}),"\n",(0,s.jsxs)(t.p,{children:["The methods specified in the ",(0,s.jsx)(t.code,{children:"methods"})," array are invoked via reflection on ",(0,s.jsx)(t.code,{children:"clazz"})," (the test template class by default). Each method should return a ",(0,s.jsx)(t.code,{children:"List<DerivationParameter>"}),"."]}),"\n",(0,s.jsx)(t.h3,{id:"explicitmodelingconstraints",children:(0,s.jsx)(t.code,{children:"ExplicitModelingConstraints"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:"public @interface ExplicitModelingConstraints {\n    Class<?> clazz() default Object.class;\n    String[] affectedIdentifiers();\n    String[] methods();\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["This annotation replaces the default constraints for parameters with explicitly defined constraints. Each method in the ",(0,s.jsx)(t.code,{children:"methods"})," array should return a list of ",(0,s.jsx)(r.A,{path:"TLS-Test-Framework/src/main/java/de/rub/nds/tlstest/framework/model/constraint/ConditionalConstraint.java"})," instances to be applied to the parameter at the corresponding index of the ",(0,s.jsx)(t.code,{children:"affectedIdentifiers"})," array."]})]})}function m(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}}}]);