"use strict";(self.webpackChunktls_anvil_docs=self.webpackChunktls_anvil_docs||[]).push([[730],{3997:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>d,metadata:()=>o,toc:()=>h});var s=a(5893),i=a(1151),n=a(6797),r=a(1293);const d={},l="Modifying the IPM",o={id:"Adding-New-Tests/Modifying-the-IPM-Model",title:"Modifying the IPM",description:"As described before, TLS-Anvil defines 4 common IPMs. Sometimes different parameters and/or parameter values should be part of the IPM. Therefore, the Anvil-Core-Framework provides several test template annotations that allow to modify a selected base IPM. Those are explained in the following.",source:"@site/docs/05-Adding-New-Tests/04-Modifying-the-IPM-Model.md",sourceDirName:"05-Adding-New-Tests",slug:"/Adding-New-Tests/Modifying-the-IPM-Model",permalink:"/docs/Adding-New-Tests/Modifying-the-IPM-Model",draft:!1,unlisted:!1,editUrl:"https://github.com/tls-attacker/TLS-Anvil/tree/main/Docs/docs/05-Adding-New-Tests/04-Modifying-the-IPM-Model.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Base IPMs",permalink:"/docs/Adding-New-Tests/IPM-Models"}},c={},h=[{value:"Modifying Parameters",id:"modifying-parameters",level:2},{value:"<code>IncludeParameter</code>",id:"includeparameter",level:3},{value:"<code>ExcludeParameter</code>",id:"excludeparameter",level:3},{value:"Modifying Parameter Values",id:"modifying-parameter-values",level:2},{value:"<code>DynamicValueConstraints</code>",id:"dynamicvalueconstraints",level:3},{value:"<code>ValueConstraint</code>",id:"valueconstraint",level:3},{value:"<code>ExplicitValues</code>",id:"explicitvalues",level:3},{value:"<code>ExplicitModelingConstraints</code>",id:"explicitmodelingconstraints",level:3}];function m(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"modifying-the-ipm",children:"Modifying the IPM"}),"\n",(0,s.jsx)(t.p,{children:"As described before, TLS-Anvil defines 4 common IPMs. Sometimes different parameters and/or parameter values should be part of the IPM. Therefore, the Anvil-Core-Framework provides several test template annotations that allow to modify a selected base IPM. Those are explained in the following."}),"\n",(0,s.jsx)(t.h2,{id:"modifying-parameters",children:"Modifying Parameters"}),"\n",(0,s.jsx)(t.h3,{id:"includeparameter",children:(0,s.jsx)(t.code,{children:"IncludeParameter"})}),"\n",(0,s.jsxs)(t.p,{children:["Takes a string corresponding to the enum value of ",(0,s.jsx)(t.code,{children:"TlsParameterType"})," for the parameter that should be added to the base IPM. The values for the parameter are derived automatically from the features that the ",(0,s.jsx)(r.Z,{id:"SUT"})," supports as well as the general constraints."]}),"\n",(0,s.jsx)(t.h3,{id:"excludeparameter",children:(0,s.jsx)(t.code,{children:"ExcludeParameter"})}),"\n",(0,s.jsxs)(t.p,{children:["Takes a string corresponding to the enum value of ",(0,s.jsx)(t.code,{children:"TlsParameterType"})," for the parameter that should be removed from the base IPM."]}),"\n",(0,s.jsx)(t.h2,{id:"modifying-parameter-values",children:"Modifying Parameter Values"}),"\n",(0,s.jsx)(t.h3,{id:"dynamicvalueconstraints",children:(0,s.jsx)(t.code,{children:"DynamicValueConstraints"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:"public @interface DynamicValueConstraints {\n    Class<?> clazz() default Object.class;\n    String[] affectedIdentifiers();\n    String[] methods();\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Each method of the ",(0,s.jsx)(t.code,{children:"methods"})," array is called with the chosen parameter value of the parameter defined at the same index of the ",(0,s.jsx)(t.code,{children:"affectedIdentifiers"})," array. When no ",(0,s.jsx)(t.code,{children:"clazz"})," is specified, the method is called using reflection on the same class as the test template."]}),"\n",(0,s.jsxs)(t.p,{children:["The method should return a ",(0,s.jsx)(t.code,{children:"boolean"})," value. If the return value is ",(0,s.jsx)(t.code,{children:"true"}),", the combination of parameter values is considered as valid test input. Otherwise the test input is skipped."]}),"\n",(0,s.jsx)(t.h3,{id:"valueconstraint",children:(0,s.jsx)(t.code,{children:"ValueConstraint"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:"public @interface ValueConstraints {\n    DerivationType identifier();\n    String method();\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Some parameter values are based on TLS-Attacker enums, e.g. ",(0,s.jsx)(n.Z,{path:"TLS-Test-Framework/src/main/java/de/rub/nds/tlstest/framework/model/derivationParameter/CipherSuiteDerivation.java"}),". Those enums in TLS-Attacker already include methods that return a ",(0,s.jsx)(t.code,{children:"boolean"})," value to check if the enum value fullfills certain parameters."]}),"\n",(0,s.jsxs)(t.p,{children:["The method specified in the ",(0,s.jsx)(t.code,{children:"method"})," field is called by using reflection on the selected enum corresponding to the identifier. If the return value is ",(0,s.jsx)(t.code,{children:"true"}),", the combination of parameter values is considered as valid test input. Otherwise the test input is skipped."]}),"\n",(0,s.jsx)(t.h3,{id:"explicitvalues",children:(0,s.jsx)(t.code,{children:"ExplicitValues"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:"public @interface ExplicitValues {\n    Class<?> clazz() default Object.class;\n    String[] affectedIdentifiers();\n    String[] methods();\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Sometimes explicit values should be considered as parameter value, independent from the features that the ",(0,s.jsx)(r.Z,{id:"SUT"})," supports. Those values are assigned to a parameter using this annotation."]}),"\n",(0,s.jsxs)(t.p,{children:["The methods specified in the ",(0,s.jsx)(t.code,{children:"methods"})," array are called by using reflection on ",(0,s.jsx)(t.code,{children:"clazz"})," (test template class by default). The return value of the method should be ",(0,s.jsx)(t.code,{children:"List<DerivationParameter>"}),"."]}),"\n",(0,s.jsx)(t.h3,{id:"explicitmodelingconstraints",children:(0,s.jsx)(t.code,{children:"ExplicitModelingConstraints"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:"public @interface ExplicitModelingConstraints {\n    Class<?> clazz() default Object.class;\n    String[] affectedIdentifiers();\n    String[] methods();\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["This annotation replaces default constraints for a parameter with explicitly defined constraints. Each method of the ",(0,s.jsx)(t.code,{children:"methods"})," array should return a list of ",(0,s.jsx)(n.Z,{path:"TLS-Test-Framework/src/main/java/de/rub/nds/tlstest/framework/model/constraint/ConditionalConstraint.java"})," that should be applied to the given parameter at the correspondending index off the ",(0,s.jsx)(t.code,{children:"affectedIdentifiers"})," array."]})]})}function u(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(m,{...e})}):m(e)}},1293:(e,t,a)=>{a.d(t,{Z:()=>l});a(7294);var s=a(7083);a(8846);const i={tag:"tag_sbMh"},n={ipm:{long:"Input Parameter Model",definition:"Contains all relevant test parameters and their values. The IPM is used to generate the test inputs (one value is assigned to each parameter) by using t-way combinatorial testing. Seperate IPMs are defined for each test template, depending on the requirement that the test template checks. Dynamically inserted constraints are applied to the IPM to ensure that for each parameter only values are used that are supported by the SUT."},sut:{long:"System Under Test",definition:"The TLS client or server that you want to test using TLS-Anvil."},"test input(s)?":{long:"Test Input",definition:"A test input is basically a dictionary that contains a single value for each parameter of an IPM. Test inputs are automatically generated from the IPM using t-way combinatorial testing. A test template is executed multiple times using a different test input for each execution."},"test template(s)?":{long:"Test Template",definition:"A test template defines the desired outcome for all test cases derived from it. Thus, it represents a test oracle that is applicable to all derived test cases. Each test template tests a different requirement and is implemented as a normal JUnit test. It basically consists of two building blocks. First it defines which TLS messages are sent and expected to be received by the test suite. Second, it defines when a test case succeeds or fails."},"test case(s)?":{long:"Test Case",definition:"A test case is the (automatically) instantiated version of test template with one specific test input."}};var r=a(5893);const d=Object.keys(n);function l(e){let{id:t}=e;const a=d.map((e=>[new RegExp(e,"i").test(t),e])).filter((e=>e[0]))[0][1],l=n[a];return(0,r.jsx)(r.Fragment,{children:(0,r.jsx)(s.ZP,{content:(0,r.jsx)(o,{details:l}),placement:"bottom",arrow:!0,hideOnClick:!0,children:(0,r.jsxs)("span",{className:i.tag,children:[t,"\xa0\u24d8"]})})})}function o(e){let{details:t}=e;return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)("div",{children:t.long}),(0,r.jsx)("hr",{style:{marginTop:"4px",marginBottom:"4px"}}),(0,r.jsx)("div",{children:t.definition})]})}},6797:(e,t,a)=>{a.d(t,{Z:()=>i});a(7294);var s=a(5893);function i(e){let{path:t}=e;const a=t.replace(".java","").split("/").reverse();return(0,s.jsx)(s.Fragment,{children:(0,s.jsx)("a",{href:"https://github.com/tls-attacker/TLS-Anvil/tree/main/"+t,children:a[0]})})}}}]);